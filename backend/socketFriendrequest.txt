require("dotenv").config();
const express = require("express");
const { Server } = require("socket.io");
const http = require("http");
const cors = require("cors");
const sequelize = require("./config/database");
const userRoutes = require("./routes/users");
const { createMessage } = require("./controllers/messageController");

const app = express();
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: "*",
  },
});

app.use(express.json());
app.use(cors());
app.use("/users", userRoutes);

const PORT = process.env.PORT || 5000;

// const users = {};

// io.on("connection", (socket) => {
//   console.log("User connected:", socket.id);

//   // When user logs in, store their socket.id by userId
//   socket.on("login", (userId) => {
//     users[userId] = socket.id;
//     console.log(`User logged in: ${userId}`);

//     // Broadcast updated user list to everyone
//     io.emit("users_update", Object.keys(users));
//   });

//   // Listen for private message: { from, to, message }
//   socket.on("private_message", ({ from, to, message }) => {
//     const recipientSocketId = users[to];
//     if (recipientSocketId) {
//       io.to(recipientSocketId).emit("private_message", { from, message });
//     } else {
//       console.log(`User ${to} not online`);
//       // Optionally handle offline messages here
//     }
//   });

//   socket.on("disconnect", () => {
//     for (const [userId, socketId] of Object.entries(users)) {
//       if (socketId === socket.id) {
//         delete users[userId];
//         console.log(`User disconnected: ${userId}`);
//         // Broadcast updated user list after disconnect
//         io.emit("users_update", Object.keys(users));
//         break;
//       }
//     }
//   });
// });

const users = {}; // userId => socket.id
const friendRequests = {}; // userId => Set of userIds who sent friend requests
const friends = {}; // userId => Set of friends' userIds

io.on("connection", (socket) => {
  console.log("User connected:", socket.id);

  socket.on("login", (userId) => {
    users[userId] = socket.id;
    if (!friendRequests[userId]) friendRequests[userId] = new Set();
    if (!friends[userId]) friends[userId] = new Set();

    io.emit("users_update", Object.keys(users));
  });

  socket.on("send_friend_request", ({ fromUserId, toUserId }) => {
    if (!friendRequests[toUserId]) friendRequests[toUserId] = new Set();
    friendRequests[toUserId].add(fromUserId);

    const recipientSocketId = users[toUserId];
    if (recipientSocketId) {
      io.to(recipientSocketId).emit("friend_request_received", { fromUserId });
    }
  });

  socket.on("accept_friend_request", ({ fromUserId, toUserId }) => {
    friendRequests[toUserId]?.delete(fromUserId);

    if (!friends[toUserId]) friends[toUserId] = new Set();
    if (!friends[fromUserId]) friends[fromUserId] = new Set();

    friends[toUserId].add(fromUserId);
    friends[fromUserId].add(toUserId);

    const toSocket = users[toUserId];
    const fromSocket = users[fromUserId];

    if (toSocket)
      io.to(toSocket).emit("friend_request_accepted", { userId: fromUserId });
    if (fromSocket)
      io.to(fromSocket).emit("friend_request_accepted", { userId: toUserId });
  });

  socket.on("deny_friend_request", ({ fromUserId, toUserId }) => {
    friendRequests[toUserId]?.delete(fromUserId);

    const senderSocketId = users[fromUserId];
    if (senderSocketId) {
      io.to(senderSocketId).emit("friend_request_denied", { userId: toUserId });
    }
  });

  socket.on("get_friend_requests", (userId) => {
    const incoming = friendRequests[userId]
      ? Array.from(friendRequests[userId])
      : [];
    socket.emit("friend_requests_list", { incoming });
  });

  socket.on("get_friends", (userId) => {
    const userFriends = friends[userId] ? Array.from(friends[userId]) : [];
    socket.emit("friends_list", { friends: userFriends });
  });

  // Listen for private message: { from, to, message }
  socket.on("private_message", ({ from, to, message }) => {
    const recipientSocketId = users[to];
    if (recipientSocketId) {
      io.to(recipientSocketId).emit("private_message", { from, message });
    } else {
      console.log(`User ${to} not online`);
      // Optionally handle offline messages here
    }
  });

  socket.on("friend_message", ({ from, to, message }) => {
    if (friends[from]?.has(to)) {
      const recipientSocketId = users[to];
      if (recipientSocketId) {
        io.to(recipientSocketId).emit("friend_message", { from, message });
      }
    } else {
      const senderSocketId = users[from];
      if (senderSocketId) {
        io.to(senderSocketId).emit("error_message", {
          message: "You can only message friends.",
        });
      }
    }
  });

  socket.on("disconnect", () => {
    for (const [userId, socketId] of Object.entries(users)) {
      if (socketId === socket.id) {
        delete users[userId];
        io.emit("users_update", Object.keys(users));
        break;
      }
    }
  });
});

// Sync the database
sequelize
  .sync({ alter: true }) // or { force: true } to drop and recreate tables
  .then(() => {
    console.log("Database synchronized successfully.");
    server.listen(PORT, () => {
      console.log(`Server running on http://localhost:${PORT}`);
    });
  })
  .catch((error) => {
    console.error("Error syncing the database:", error);
  });

// socket.on('send_message', async (data) => {
//   try {
//     const { token, username, content } = data;

//     const messageData = await createMessage(token, username, content);

//     io.emit(`receive_message`, messageData);
//     socket.emit('success_message', 'Message sent successfully!');
//   } catch (error) {
//     console.error('Error in socket:', error.message);
//     socket.emit('error_message', error.message);
//   }
// });

// socket.on('disconnect', () => {
//   console.log('User disconnected:', socket.id);
// });
